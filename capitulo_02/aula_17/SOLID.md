# S.O.L.I.D

- O SOLID é um acrônimo que representa cinco princípios de design de software que, quando aplicados corretamente, podem tornar um software mais fácil de manter e evoluir. Os princípios SOLID foram definidos por Robert C. Martin, também conhecido como Uncle Bob, em 2000, e são amplamente utilizados em desenvolvimento de software orientado a objetos. Os princípios SOLID são:

## Single Responsability Principle (Princípio da Responsabilidade Única)

- O Princípio da Responsabilidade Única é uma diretriz de design de software que preconiza que cada classe ou módulo deve ter uma única responsabilidade. Em outras palavras, uma classe deve ter apenas uma razão para ser alterada. O Princípio da Responsabilidade Única é amplamente utilizado em design de software orientado a objetos, onde é comum dividir o sistema em classes ou módulos, cada um com uma responsabilidade bem definida e interfaces claras com outros componentes do sistema. Ele também é aplicável a outras abordagens de design de software, como arquitetura em camadas e arquitetura baseada em serviços.

## Open/Closed Principle (Princípio do “Aberto para Extensão/Fechado para Implementação)

- O Princípio do “Aberto para Extensão/Fechado para Implementação” é uma diretriz de design de software que preconiza que as entidades de software (classes, módulos, funções, etc.) devem estar abertas para extensão, mas fechadas para modificação. Em outras palavras, uma classe deve ser projetada de forma que novas funcionalidades possam ser adicionadas sem a necessidade de alterar o código fonte da própria classe. O Princípio do “Aberto para Extensão/Fechado para Implementação” é amplamente utilizado em design de software orientado a objetos, onde é comum dividir o sistema em classes ou módulos, cada um com uma responsabilidade bem definida e interfaces claras com outros componentes do sistema. Ele também é aplicável a outras abordagens de design de software, como arquitetura em camadas e arquitetura baseada em serviços.

## Liskov Substitution Principle (Princípio da Substituição de Liskov)

- O Princípio da Substituição de Liskov é uma diretriz de design de software que preconiza que as classes derivadas devem ser substituíveis por suas classes base. Em outras palavras, uma classe derivada deve ser capaz de substituir sua classe base sem quebrar o código que a utiliza. O Princípio da Substituição de Liskov é amplamente utilizado em design de software orientado a objetos, onde é comum dividir o sistema em classes ou módulos, cada um com uma responsabilidade bem definida e interfaces claras com outros componentes do sistema. Ele também é aplicável a outras abordagens de design de software, como arquitetura em camadas e arquitetura baseada em serviços.

## Interface Segregation Principle (Princípio da Segregação de Interfaces)

- O Princípio da Segregação de Interfaces é uma diretriz de design de software que preconiza que nenhuma classe deve ser forçada a depender de métodos que ela não irá utilizar. Em outras palavras, uma classe não deve ser forçada a implementar interfaces e métodos que não irá utilizar. O Princípio da Segregação de Interfaces é amplamente utilizado em design de software orientado a objetos, onde é comum dividir o sistema em classes ou módulos, cada um com uma responsabilidade bem definida e interfaces claras com outros componentes do sistema. Ele também é aplicável a outras abordagens de design de software, como arquitetura em camadas e arquitetura baseada em serviços.

## Dependency Inversion Principle (Princípio da Inversão de Dependências)

- O Princípio da Inversão de Dependências é uma diretriz de design de software que preconiza que as classes de alto nível não devem depender de classes de baixo nível. Em outras palavras, uma classe não deve ser forçada a depender de classes que ela não irá utilizar. O Princípio da Inversão de Dependências é amplamente utilizado em design de software orientado a objetos, onde é comum dividir o sistema em classes ou módulos, cada um com uma responsabilidade bem definida e interfaces claras com outros componentes do sistema. Ele também é aplicável a outras abordagens de design de software, como arquitetura em camadas e arquitetura baseada em serviços.